Prompt Outline: GYM AI Engine (Comprehensive Overview)
System Role & High-Level Concept
You are analyzing a full-stack web application called "GYM AI Engine." This app provides an AI-driven chat interface with the following goals:

Host chat conversations (with memory) about user topics.
Generate downloadable Microsoft Word (DOCX) “reports” from chat content.
Store all user chats in Azure Cosmos DB, one container named chats.
Leverage Azure OpenAI for natural language completions.
Include additional tools for file upload/analysis (PDF, images, docx).
Provide search-based retrieval from local or Azure Cognitive Search indexes.
1. Frontend (React) Architecture
1.1 Overall Structure

A React Single-Page Application (SPA).
Organized into multiple major components:
ChatInterface.jsx – the main chat UI component.
TrainDocTool.jsx – for uploading or training docs.
FacilityTool.jsx – for “club control” or facility management.
Navigation is implemented with a horizontal slider or tabbed approach.
1.2 Key Props & State

chatId: The unique ID assigned to each conversation.
messages: An array of message objects, each containing { role, content, attachedFiles, etc. }.
userKey: The partition key in Cosmos DB (derived from the user’s identity).
chatTitle: The short descriptive title for each conversation.
reportContent / downloadUrl: Optional fields for returning a doc link.
1.3 UI Layout

Top Bar:
Logo & brand name (Loklən / “GYM AI Engine”).
Nav to switch among “Training & Document Control,” “Chat,” “Club Control.”
Chat History button & a hamburger menu for settings, new chat, logout, share.
Main Body:
Horizontal slider with 3 “pages”:
Training & Document Control (TrainDocTool)
Chat (ChatInterface)
Club Control (FacilityTool)
Footer:
“Powered by Mahlum Innovations, LLC” (clickable link).
1.4 Settings & Menus

Settings includes theme toggling (dark/light/system), AI instructions, local archived chats, contact form, etc.
“Share” sub-menu for email or docx transcript downloads.
2. Chat Logic in React
ChatInterface manages local state for messages, user input, file attachments, loading status, etc.
On each user “Send,” it does:
Pushes user’s message to local messages.
Calls POST /chat (or sometimes POST /chat with multipart/form-data if attachments).
Receives assistant’s reply from the server, updates messages.
Possibly auto-generates a chat title after the first user–assistant exchange, then calls POST /renameChat.
The UI provides a text area for user input, a paperclip icon for attachments, and a “Send” button.
3. Backend (Flask + Azure Cosmos + Azure Storage)
3.1 app.py – The main Python/Flask server

Provides endpoints:
GET / → Serves the React app index.html.
POST /chat or GET /chat (depending on the approach):
Upserts conversation docs to Cosmos DB.
Calls AzureOpenAI to generate a response.
If user requests a “downloadable report,” returns a special download://report.docx placeholder that triggers further logic in the client.
GET /api/generateReport:
Returns a .docx file built from the expanded content.
POST /contact → SendGrid email.
GET /chats → Lists all user’s chat docs.
POST /archiveAllChats, POST /deleteAllChats → Archive or fully remove chats from Cosmos DB + remove associated blobs from Azure Storage.
POST /renameChat → Rename a chat doc in Cosmos DB.
POST /uploadLargeFile, POST /askDoc → Additional endpoints for uploading large docs or doing question–answer with Azure Cognitive Search context.
3.2 Cosmos DB

PartitionKey: The field userKey so each user’s chats are stored in their own logical partition.
Each doc typically shaped like:
jsonc
Copy code
{
  "id": "chat_1689286622222_1234_johndoe",
  "userKey": "johndoe",
  "messages": [
    { "role": "system", "content": "System content..." },
    { "role": "user", "content": "User text..." },
    { "role": "assistant", "content": "Assistant text..." }
  ],
  "files": [
    { "filename": "some.pdf", "blobUrl": "...", "fileExt": "pdf", "extractedText": "..." }
  ],
  "title": "An optional short chat title"
}
3.3 AzureOpenAI

The code calls client.chat.completions.create(...) with messages array.
If the user requests a “downloadable report,” the system message or user message triggers returning download://report.docx.
3.4 File Upload & Analysis

If the user attaches files:
The server reads them from request.files.
Uploads them to an Azure Blob container (e.g., “gymaitempcontainer”).
Optionally runs a Vision or Form Recognizer call to get extracted text.
3.5 Report Generation

If “download://report.docx” is found, the backend:
Creates a big expanded text from the partial answer.
Stores that text in an in-memory report_cache.
Sends back a special link (/api/generateReport?reportId=<some-uuid>).
GET /api/generateReport then:
Looks up report_cache[reportId].
Uses python-docx to create a Word doc with headings, bullet points, bold text, etc.
Streams it back via send_file.
4. Memory & Chat ID Approaches
4.1 Approach A (Upsert-based with POST /chat)

The front-end sends chatId if continuing a conversation; if none, it tries to generate a brand-new ID.
The server does an upsert_item(...) on Cosmos DB.
Possibly leads to 409 conflicts if ID + partitionKey already exist.
4.2 Approach B (Always create new doc with new ID)

The front-end or the server always ensures the new ID is globally unique if the user wants a “new” chat.
If the user has an existing ID, read the doc from that partition.
Minimizes conflicts but can produce many chat docs over time.
4.3 Memory

Each chat doc has the entire messages array. The server includes those messages as context to AzureOpenAI.
This is how the AI “remembers” prior user messages in that chat.
5. AI Title Generation
There is a special endpoint: POST /generateChatTitle.
The front-end can send a snippet of messages. The server calls AzureOpenAI with a system instruction to produce a short 3–6 word title.
This result is stored into the doc’s title field.
6. Implementation Notes & Tools
Frontend: React + TailwindCSS or similar for styling, plus Vite or Webpack build.
Backend: Python 3.9 with Flask, gunicorn, azure-cosmos, azure-storage-blob, azure-ai-formrecognizer, azure.search.documents, etc.
Azure Cloud:
Cosmos DB for storing user chat docs.
Azure Blob Storage for file uploads.
Azure OpenAI for completions.
(Optional) Azure Cognitive Search for chunk-based doc retrieval.
SendGrid for contact form emails.
7. Security / Partitioning
Each user has a userKey that acts as the partition key.
The app ensures that a user only reads/writes chat docs in their own partition.
Deleting all chats calls DELETE /deleteAllChats which iterates all docs in the userKey partition and removes them.
8. How the App Flows
User logs in (maybe via Azure AD or MSAL?).
Frontend loads. The user sees the top bar with 3 sections.
User goes to the Chat page, possibly picks an old chat or starts a brand-new one.
User sends a question → The ChatInterface calls POST /chat with the message.
Backend upserts the doc in Cosmos DB, calls AzureOpenAI.
Backend returns the assistant’s reply (plus references, or a doc link if needed).
User sees the conversation update. If the conversation is new, it might request POST /generateChatTitle to rename the doc.
If the user wants a full doc, the AI returns download://report.docx, the front-end modifies the text to include a link to GET /api/generateReport?reportId=some-uuid, which the user can click to download.
9. Troubleshooting / Common Errors
409 “Conflict” in Cosmos DB if you re-use an existing ID.
500 “Invalid start byte” might appear in logs if your environment tries to read a Python file with non-UTF-8 text.
Memory issues if you do not pass older conversation messages to AzureOpenAI.
CORS or JSON parse issues if your React dev server is not aligned with your Flask server config.
10. Additional Implementation Details
The code uses requests or axios on the front-end to talk to the Flask endpoints.
For multi-file upload, the front-end uses multipart/form-data. The server uses Flask.request.files.
The doc rendering in Python uses python-docx. It checks for headings with # or bullet points with - and bold text with **.
The environment variables (like COSMOS_ENDPOINT, AZURE_OPENAI_KEY, etc.) must be set.